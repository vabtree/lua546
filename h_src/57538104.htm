<html>
<head>
<!-- This html document was created by Imagix 4D -->
<link href="../htm/symbol.css" rel="stylesheet" type="text/css">
<link href="../htm/symcolors.css" rel="stylesheet" type="text/css">
<link href="../htm/notebook.css" rel="stylesheet" type="text/css">
<base target="symbol">
</head>
<body>

<h2>lstate.h</h2>

<div class="notebook">
<ul>
<li><a href="../h_aa/57538104.htm" class="file" target="_self">Info</a></li>
<li><a href="../h_im/57538104.htm" class="file" target="_self">Global Interface</a></li>
<li><a href="../h_rx/57538104.htm" class="file" target="_self">File Inclusion</a></li>
<li><a href="../h_nm/57538104.htm" class="file" target="_self">Internals</a></li>
<li><a href="../h_ua/57538104.htm" class="file" target="_self">Use of Elements</a></li>
<li><a href="../h_da/57538104.htm" class="file" target="_self">Dependencies</a></li>
<li id="current"><a href="../h_src/57538104.htm" class="file" target="_self">Source Code</a></li>
</ul>
</div>
<div class="notebook">
<ul>
<li id="current"><a href="../h_src/57538104.htm" class="file" target="_self">Source Code</a></li>
<li><a href="../h_sc/57538104.htm" class="file" target="_self">Source Checks</a></li>
</ul>
</div>
<div class="nb_clear">
</div>
<pre class=src>
<a id=1></a><a  class="comments">/*</a>
<a id=2></a><a  class="comments">** $Id: lstate.h $</a>
<a id=3></a><a  class="comments">** Global State</a>
<a id=4></a><a  class="comments">** See Copyright Notice in lua.h</a>
<a id=5></a><a  class="comments">*/</a>

<a id=7></a>#ifndef <a href="../h_src/57538036.htm" class="macro">lstate_h</a>
<a id=8></a>#define <a href="../h_src/57537900.htm" class="macro">lstate_h</a>

<a id=10></a>#include &quot;<a href="../h_src/57460028.htm" class="file">lua.h</a>&quot;


<a id=13></a><a  class="comments">/* Some header files included here need this definition */</a>
<a id=14></a>typedef struct <a href="../h_src/57422696.htm" class="class">CallInfo</a> <a href="../h_src/57537764.htm" class="type">CallInfo</a>;


<a id=17></a>#include &quot;<a href="../h_src/57537696.htm" class="file">lobject.h</a>&quot;
<a id=18></a>#include &quot;<a href="../h_src/57501248.htm" class="file">ltm.h</a>&quot;
<a id=19></a>#include &quot;<a href="../h_src/57497236.htm" class="file">lzio.h</a>&quot;


<a id=22></a><a  class="comments">/*</a>
<a id=23></a><a  class="comments">** Some notes about garbage-collected objects: All objects in Lua must</a>
<a id=24></a><a  class="comments">** be kept somehow accessible until being freed, so all objects always</a>
<a id=25></a><a  class="comments">** belong to one (and only one) of these lists, using field 'next' of</a>
<a id=26></a><a  class="comments">** the 'CommonHeader' for the link:</a>
<a id=27></a><a  class="comments">**</a>
<a id=28></a><a  class="comments">** 'allgc': all objects not marked for finalization;</a>
<a id=29></a><a  class="comments">** 'finobj': all objects marked for finalization;</a>
<a id=30></a><a  class="comments">** 'tobefnz': all objects ready to be finalized;</a>
<a id=31></a><a  class="comments">** 'fixedgc': all objects that are not to be collected (currently</a>
<a id=32></a><a  class="comments">** only small strings, such as reserved words).</a>
<a id=33></a><a  class="comments">**</a>
<a id=34></a><a  class="comments">** For the generational collector, some of these lists have marks for</a>
<a id=35></a><a  class="comments">** generations. Each mark points to the first element in the list for</a>
<a id=36></a><a  class="comments">** that particular generation; that generation goes until the next mark.</a>
<a id=37></a><a  class="comments">**</a>
<a id=38></a><a  class="comments">** 'allgc' -&gt; 'survival': new objects;</a>
<a id=39></a><a  class="comments">** 'survival' -&gt; 'old': objects that survived one collection;</a>
<a id=40></a><a  class="comments">** 'old1' -&gt; 'reallyold': objects that became old in last collection;</a>
<a id=41></a><a  class="comments">** 'reallyold' -&gt; NULL: objects old for more than one cycle.</a>
<a id=42></a><a  class="comments">**</a>
<a id=43></a><a  class="comments">** 'finobj' -&gt; 'finobjsur': new objects marked for finalization;</a>
<a id=44></a><a  class="comments">** 'finobjsur' -&gt; 'finobjold1': survived   &quot;&quot;&quot;&quot;;</a>
<a id=45></a><a  class="comments">** 'finobjold1' -&gt; 'finobjrold': just old  &quot;&quot;&quot;&quot;;</a>
<a id=46></a><a  class="comments">** 'finobjrold' -&gt; NULL: really old       &quot;&quot;&quot;&quot;.</a>
<a id=47></a><a  class="comments">**</a>
<a id=48></a><a  class="comments">** All lists can contain elements older than their main ages, due</a>
<a id=49></a><a  class="comments">** to 'luaC_checkfinalizer' and 'udata2finalize', which move</a>
<a id=50></a><a  class="comments">** objects between the normal lists and the &quot;marked for finalization&quot;</a>
<a id=51></a><a  class="comments">** lists. Moreover, barriers can age young objects in young lists as</a>
<a id=52></a><a  class="comments">** OLD0, which then become OLD1. However, a list never contains</a>
<a id=53></a><a  class="comments">** elements younger than their main ages.</a>
<a id=54></a><a  class="comments">**</a>
<a id=55></a><a  class="comments">** The generational collector also uses a pointer 'firstold1', which</a>
<a id=56></a><a  class="comments">** points to the first OLD1 object in the list. It is used to optimize</a>
<a id=57></a><a  class="comments">** 'markold'. (Potentially OLD1 objects can be anywhere between 'allgc'</a>
<a id=58></a><a  class="comments">** and 'reallyold', but often the list has no OLD1 objects or they are</a>
<a id=59></a><a  class="comments">** after 'old1'.) Note the difference between it and 'old1':</a>
<a id=60></a><a  class="comments">** 'firstold1': no OLD1 objects before this point; there can be all</a>
<a id=61></a><a  class="comments">**   ages after it.</a>
<a id=62></a><a  class="comments">** 'old1': no objects younger than OLD1 after this point.</a>
<a id=63></a><a  class="comments">*/</a>

<a id=65></a><a  class="comments">/*</a>
<a id=66></a><a  class="comments">** Moreover, there is another set of lists that control gray objects.</a>
<a id=67></a><a  class="comments">** These lists are linked by fields 'gclist'. (All objects that</a>
<a id=68></a><a  class="comments">** can become gray have such a field. The field is not the same</a>
<a id=69></a><a  class="comments">** in all objects, but it always has this name.)  Any gray object</a>
<a id=70></a><a  class="comments">** must belong to one of these lists, and all objects in these lists</a>
<a id=71></a><a  class="comments">** must be gray (with two exceptions explained below):</a>
<a id=72></a><a  class="comments">**</a>
<a id=73></a><a  class="comments">** 'gray': regular gray objects, still waiting to be visited.</a>
<a id=74></a><a  class="comments">** 'grayagain': objects that must be revisited at the atomic phase.</a>
<a id=75></a><a  class="comments">**   That includes</a>
<a id=76></a><a  class="comments">**   - black objects got in a write barrier;</a>
<a id=77></a><a  class="comments">**   - all kinds of weak tables during propagation phase;</a>
<a id=78></a><a  class="comments">**   - all threads.</a>
<a id=79></a><a  class="comments">** 'weak': tables with weak values to be cleared;</a>
<a id=80></a><a  class="comments">** 'ephemeron': ephemeron tables with white-&gt;white entries;</a>
<a id=81></a><a  class="comments">** 'allweak': tables with weak keys and/or weak values to be cleared.</a>
<a id=82></a><a  class="comments">**</a>
<a id=83></a><a  class="comments">** The exceptions to that &quot;gray rule&quot; are:</a>
<a id=84></a><a  class="comments">** - TOUCHED2 objects in generational mode stay in a gray list (because</a>
<a id=85></a><a  class="comments">** they must be visited again at the end of the cycle), but they are</a>
<a id=86></a><a  class="comments">** marked black because assignments to them must activate barriers (to</a>
<a id=87></a><a  class="comments">** move them back to TOUCHED1).</a>
<a id=88></a><a  class="comments">** - Open upvales are kept gray to avoid barriers, but they stay out</a>
<a id=89></a><a  class="comments">** of gray lists. (They don't even have a 'gclist' field.)</a>
<a id=90></a><a  class="comments">*/</a>



<a id=94></a><a  class="comments">/*</a>
<a id=95></a><a  class="comments">** About 'nCcalls':  This count has two parts: the lower 16 bits counts</a>
<a id=96></a><a  class="comments">** the number of recursive invocations in the C stack; the higher</a>
<a id=97></a><a  class="comments">** 16 bits counts the number of non-yieldable calls in the stack.</a>
<a id=98></a><a  class="comments">** (They are together so that we can change and save both with one</a>
<a id=99></a><a  class="comments">** instruction.)</a>
<a id=100></a><a  class="comments">*/</a>


<a id=103></a><a  class="comments">/* true if this thread does not have non-yieldable calls in the stack */</a>
<a id=104></a>#define <a href="../h_src/57653776.htm" class="macro">yieldable</a>(L)		(((L)-&gt;nCcalls &amp; 0xffff0000) == 0)

<a id=106></a><a  class="comments">/* real number of C calls */</a>
<a id=107></a>#define <a href="../h_src/57653640.htm" class="macro">getCcalls</a>(L)	((L)-&gt;nCcalls &amp; 0xffff)


<a id=110></a><a  class="comments">/* Increment the number of non-yieldable calls */</a>
<a id=111></a>#define <a href="../h_src/57653504.htm" class="macro">incnny</a>(L)	((L)-&gt;nCcalls += 0x10000)

<a id=113></a><a  class="comments">/* Decrement the number of non-yieldable calls */</a>
<a id=114></a>#define <a href="../h_src/57653368.htm" class="macro">decnny</a>(L)	((L)-&gt;nCcalls -= 0x10000)

<a id=116></a><a  class="comments">/* Non-yieldable call increment */</a>
<a id=117></a>#define <a href="../h_src/57653232.htm" class="macro">nyci</a>	(0x10000 | 1)




<a id=122></a>struct <a href="../h_src/57653096.htm" class="class">lua_longjmp</a>;  <a  class="comments">/* defined in ldo.c */</a>


<a id=125></a><a  class="comments">/*</a>
<a id=126></a><a  class="comments">** Atomic type (relative to signals) to better ensure that 'lua_sethook'</a>
<a id=127></a><a  class="comments">** is thread safe</a>
<a id=128></a><a  class="comments">*/</a>
<a id=129></a>#if !defined(<a href="../h_src/57652960.htm" class="macro">l_signalT</a>)
#include &lt;signal.h&gt;
<a id=131></a>#define <a href="../h_src/57652824.htm" class="macro">l_signalT</a>	sig_atomic_t
#endif


<a id=135></a><a  class="comments">/*</a>
<a id=136></a><a  class="comments">** Extra stack space to handle TM calls and some other extras. This</a>
<a id=137></a><a  class="comments">** space is not included in 'stack_last'. It is used only to avoid stack</a>
<a id=138></a><a  class="comments">** checks, either because the element will be promptly popped or because</a>
<a id=139></a><a  class="comments">** there will be a stack check soon after the push. Function frames</a>
<a id=140></a><a  class="comments">** never use this extra space, so it does not need to be kept clean.</a>
<a id=141></a><a  class="comments">*/</a>
<a id=142></a>#define <a href="../h_src/57652688.htm" class="macro">EXTRA_STACK</a>   5


<a id=145></a>#define <a href="../h_src/57652552.htm" class="macro">BASIC_STACK_SIZE</a>        (2*LUA_MINSTACK)

<a id=147></a>#define <a href="../h_src/57652416.htm" class="macro">stacksize</a>(th)	cast_int((th)-&gt;stack_last.p - (th)-&gt;stack.p)


<a id=150></a><a  class="comments">/* kinds of Garbage Collection */</a>
<a id=151></a>#define <a href="../h_src/57652280.htm" class="macro">KGC_INC</a>		0	<a  class="comments">/* incremental gc */</a>
<a id=152></a>#define <a href="../h_src/57652144.htm" class="macro">KGC_GEN</a>		1	<a  class="comments">/* generational gc */</a>


<a id=155></a>typedef struct <a href="../h_src/57652008.htm" class="class">stringtable</a> {
<a id=156></a>  <a href="../h_src/57522736.htm" class="type">TString</a> **<a href="../h_src/57651804.htm" class="variable">hash</a>;
<a id=157></a>  int <a href="../h_src/57651736.htm" class="variable">nuse</a>;  <a  class="comments">/* number of elements */</a>
<a id=158></a>  int <a href="../h_src/57651668.htm" class="variable">size</a>;
<a id=159></a>} <a href="../h_src/57651600.htm" class="type">stringtable</a>;


<a id=162></a><a  class="comments">/*</a>
<a id=163></a><a  class="comments">** Information about a call.</a>
<a id=164></a><a  class="comments">** About union 'u':</a>
<a id=165></a><a  class="comments">** - field 'l' is used only for Lua functions;</a>
<a id=166></a><a  class="comments">** - field 'c' is used only for C functions.</a>
<a id=167></a><a  class="comments">** About union 'u2':</a>
<a id=168></a><a  class="comments">** - field 'funcidx' is used only by C functions while doing a</a>
<a id=169></a><a  class="comments">** protected call;</a>
<a id=170></a><a  class="comments">** - field 'nyield' is used only while a function is &quot;doing&quot; an</a>
<a id=171></a><a  class="comments">** yield (from the yield until the next resume);</a>
<a id=172></a><a  class="comments">** - field 'nres' is used only while closing tbc variables when</a>
<a id=173></a><a  class="comments">** returning from a function;</a>
<a id=174></a><a  class="comments">** - field 'transferinfo' is used only during call/returnhooks,</a>
<a id=175></a><a  class="comments">** before the function starts or after it ends.</a>
<a id=176></a><a  class="comments">*/</a>
<a id=177></a>struct <a href="../h_src/57422696.htm" class="class">CallInfo</a> {
<a id=178></a>  <a href="../h_src/57531780.htm" class="type">StkIdRel</a> <a href="../h_src/57651532.htm" class="variable">func</a>;  <a  class="comments">/* function index in the stack */</a>
<a id=179></a>  <a href="../h_src/57531780.htm" class="type">StkIdRel</a>	<a href="../h_src/57651464.htm" class="variable">top</a>;  <a  class="comments">/* top for this function */</a>
<a id=180></a>  struct <a href="../h_src/57422696.htm" class="class">CallInfo</a> *<a href="../h_src/57651396.htm" class="variable">previous</a>, *<a href="../h_src/57651328.htm" class="variable">next</a>;  <a  class="comments">/* dynamic call link */</a>
<a id=181></a>  <a href="../h_src/57651260.htm" class="class">u</a>nion {
<a id=182></a>    struct {  <a  class="comments">/* only for Lua functions */</a>
<a id=183></a>      const <a href="../h_src/57545108.htm" class="type">Instruction</a> *<a href="../h_src/57651124.htm" class="variable">savedpc</a>;
<a id=184></a>      volatile <a href="../h_src/57652824.htm" class="macro">l_signalT</a> <a href="../h_src/57651056.htm" class="variable">trap</a>;
<a id=185></a>      int <a href="../h_src/57650988.htm" class="variable">nextraargs</a>;  <a  class="comments">/* # of extra arguments in vararg functions */</a>
<a id=186></a>    } <a href="../h_src/57650852.htm" class="variable">l</a>;
<a id=187></a>    struct {  <a  class="comments">/* only for C functions */</a>
<a id=188></a>      <a href="../h_src/57441464.htm" class="type">lua_KFunction</a> <a href="../h_src/57650716.htm" class="variable">k</a>;  <a  class="comments">/* continuation in case of yields */</a>
<a id=189></a>      <a href="../h_aa/57441872.htm" class="type">ptrdiff_t</a> <a href="../h_src/57650648.htm" class="variable">old_errfunc</a>;
<a id=190></a>      <a href="../h_src/57441940.htm" class="type">lua_KContext</a> <a href="../h_src/57650580.htm" class="variable">ctx</a>;  <a  class="comments">/* context info. in case of yields */</a>
<a id=191></a>    } <a href="../h_src/57650444.htm" class="variable">c</a>;
<a id=192></a>  } <a href="../h_src/57650308.htm" class="variable">u</a>;
  union {
<a id=194></a>    int <a href="../h_src/57650172.htm" class="variable">funcidx</a>;  <a  class="comments">/* called-function index */</a>
<a id=195></a>    int <a href="../h_src/57650104.htm" class="variable">nyield</a>;  <a  class="comments">/* number of values yielded */</a>
<a id=196></a>    int <a href="../h_src/57650036.htm" class="variable">nres</a>;  <a  class="comments">/* number of values returned */</a>
<a id=197></a>    struct {  <a  class="comments">/* info about transferred values (for call/return hooks) */</a>
<a id=198></a>      unsigned short <a href="../h_src/57649900.htm" class="variable">ftransfer</a>;  <a  class="comments">/* offset of first value transferred */</a>
<a id=199></a>      unsigned short <a href="../h_src/57649832.htm" class="variable">ntransfer</a>;  <a  class="comments">/* number of values transferred */</a>
<a id=200></a>    } <a href="../h_src/57649696.htm" class="variable">transferinfo</a>;
<a id=201></a>  } <a href="../h_src/57649560.htm" class="variable">u2</a>;
<a id=202></a>  short <a href="../h_src/57649492.htm" class="variable">nresults</a>;  <a  class="comments">/* expected number of results from this function */</a>
<a id=203></a>  unsigned short <a href="../h_src/57649424.htm" class="variable">callstatus</a>;
};


<a id=207></a><a  class="comments">/*</a>
<a id=208></a><a  class="comments">** Bits in CallInfo status</a>
<a id=209></a><a  class="comments">*/</a>
<a id=210></a>#define <a href="../h_src/57649356.htm" class="macro">CIST_OAH</a>	(1&lt;&lt;0)	<a  class="comments">/* original value of 'allowhook' */</a>
<a id=211></a>#define <a href="../h_src/57649220.htm" class="macro">CIST_C</a>		(1&lt;&lt;1)	<a  class="comments">/* call is running a C function */</a>
<a id=212></a>#define <a href="../h_src/57649084.htm" class="macro">CIST_FRESH</a>	(1&lt;&lt;2)	<a  class="comments">/* call is on a fresh &quot;luaV_execute&quot; frame */</a>
<a id=213></a>#define <a href="../h_src/57648948.htm" class="macro">CIST_HOOKED</a>	(1&lt;&lt;3)	<a  class="comments">/* call is running a debug hook */</a>
<a id=214></a>#define <a href="../h_src/57648812.htm" class="macro">CIST_YPCALL</a>	(1&lt;&lt;4)	<a  class="comments">/* doing a yieldable protected call */</a>
<a id=215></a>#define <a href="../h_src/57648676.htm" class="macro">CIST_TAIL</a>	(1&lt;&lt;5)	<a  class="comments">/* call was tail called */</a>
<a id=216></a>#define <a href="../h_src/57648540.htm" class="macro">CIST_HOOKYIELD</a>	(1&lt;&lt;6)	<a  class="comments">/* last hook called yielded */</a>
<a id=217></a>#define <a href="../h_src/57648404.htm" class="macro">CIST_FIN</a>	(1&lt;&lt;7)	<a  class="comments">/* function &quot;called&quot; a finalizer */</a>
<a id=218></a>#define <a href="../h_src/57648268.htm" class="macro">CIST_TRAN</a>	(1&lt;&lt;8)	<a  class="comments">/* 'ci' has transfer information */</a>
<a id=219></a>#define <a href="../h_src/57648132.htm" class="macro">CIST_CLSRET</a>	(1&lt;&lt;9)  <a  class="comments">/* function is closing tbc variables */</a>
<a id=220></a><a  class="comments">/* Bits 10-12 are used for CIST_RECST (see below) */</a>
<a id=221></a>#define <a href="../h_src/57647996.htm" class="macro">CIST_RECST</a>	10
<a id=222></a>#if defined(<a href="../h_src/57453092.htm" class="macro">LUA_COMPAT_LT_LE</a>)
<a id=223></a>#define <a href="../h_src/57647860.htm" class="macro">CIST_LEQ</a>	(1&lt;&lt;13)  <a  class="comments">/* using __lt for __le */</a>
#endif


<a id=227></a><a  class="comments">/*</a>
<a id=228></a><a  class="comments">** Field CIST_RECST stores the &quot;recover status&quot;, used to keep the error</a>
<a id=229></a><a  class="comments">** status while closing to-be-closed variables in coroutines, so that</a>
<a id=230></a><a  class="comments">** Lua can correctly resume after an yield from a __close method called</a>
<a id=231></a><a  class="comments">** because of an error.  (Three bits are enough for error status.)</a>
<a id=232></a><a  class="comments">*/</a>
<a id=233></a>#define <a href="../h_src/57647724.htm" class="macro">getcistrecst</a>(ci)     (((ci)-&gt;callstatus &gt;&gt; CIST_RECST) &amp; 7)
<a id=234></a>#define <a href="../h_src/57647588.htm" class="macro">setcistrecst</a>(ci,st)  \
<a id=235></a>  check_exp(((st) &amp; 7) == (st),   <a  class="comments">/* status must fit in three bits */</a>  \
            ((ci)-&gt;callstatus = ((ci)-&gt;callstatus &amp; ~(7 &lt;&lt; CIST_RECST))  \
                                                  | ((st) &lt;&lt; CIST_RECST)))


<a id=240></a><a  class="comments">/* active function is a Lua function */</a>
<a id=241></a>#define <a href="../h_src/57647452.htm" class="macro">isLua</a>(ci)	(!((ci)-&gt;callstatus &amp; CIST_C))

<a id=243></a><a  class="comments">/* call is running Lua code (not a hook) */</a>
<a id=244></a>#define <a href="../h_src/57647316.htm" class="macro">isLuacode</a>(ci)	(!((ci)-&gt;callstatus &amp; (CIST_C | CIST_HOOKED)))

<a id=246></a><a  class="comments">/* assume that CIST_OAH has offset 0 and that 'v' is strictly 0/1 */</a>
<a id=247></a>#define <a href="../h_src/57647180.htm" class="macro">setoah</a>(st,v)	((st) = ((st) &amp; ~CIST_OAH) | (v))
<a id=248></a>#define <a href="../h_src/57647044.htm" class="macro">getoah</a>(st)	((st) &amp; CIST_OAH)


<a id=251></a><a  class="comments">/*</a>
<a id=252></a><a  class="comments">** 'global state', shared by all threads of this state</a>
<a id=253></a><a  class="comments">*/</a>
<a id=254></a>typedef struct <a href="../h_src/57646908.htm" class="class">global_State</a> {
<a id=255></a>  <a href="../h_src/57440852.htm" class="type">lua_Alloc</a> <a href="../h_src/57646772.htm" class="variable">frealloc</a>;  <a  class="comments">/* function to reallocate memory */</a>
<a id=256></a>  void *<a href="../h_src/57646704.htm" class="variable">ud</a>;         <a  class="comments">/* auxiliary data to 'frealloc' */</a>
<a id=257></a>  <a href="../h_src/57550548.htm" class="type">l_mem</a> <a href="../h_src/57646636.htm" class="variable">totalbytes</a>;  <a  class="comments">/* number of bytes currently allocated - GCdebt */</a>
<a id=258></a>  <a href="../h_src/57550548.htm" class="type">l_mem</a> <a href="../h_src/57646568.htm" class="variable">GCdebt</a>;  <a  class="comments">/* bytes allocated not yet compensated by the collector */</a>
<a id=259></a>  <a href="../h_src/57550616.htm" class="type">lu_mem</a> <a href="../h_src/57646500.htm" class="variable">GCestimate</a>;  <a  class="comments">/* an estimate of the non-garbage memory in use */</a>
<a id=260></a>  <a href="../h_src/57550616.htm" class="type">lu_mem</a> <a href="../h_src/57646432.htm" class="variable">lastatomic</a>;  <a  class="comments">/* see function 'genstep' in file 'lgc.c' */</a>
<a id=261></a>  <a href="../h_src/57651600.htm" class="type">stringtable</a> <a href="../h_src/57646364.htm" class="variable">strt</a>;  <a  class="comments">/* hash table for strings */</a>
<a id=262></a>  <a href="../h_src/57535384.htm" class="type">TValue</a> <a href="../h_src/57646296.htm" class="variable">l_registry</a>;
<a id=263></a>  <a href="../h_src/57535384.htm" class="type">TValue</a> <a href="../h_src/57646228.htm" class="variable">nilvalue</a>;  <a  class="comments">/* a nil value */</a>
<a id=264></a>  unsigned int <a href="../h_src/57646160.htm" class="variable">seed</a>;  <a  class="comments">/* randomized seed for hashes */</a>
<a id=265></a>  <a href="../h_src/57550480.htm" class="type">lu_byte</a> <a href="../h_src/57646092.htm" class="variable">currentwhite</a>;
<a id=266></a>  <a href="../h_src/57550480.htm" class="type">lu_byte</a> <a href="../h_src/57646024.htm" class="variable">gcstate</a>;  <a  class="comments">/* state of garbage collector */</a>
<a id=267></a>  <a href="../h_src/57550480.htm" class="type">lu_byte</a> <a href="../h_src/57645956.htm" class="variable">gckind</a>;  <a  class="comments">/* kind of GC running */</a>
<a id=268></a>  <a href="../h_src/57550480.htm" class="type">lu_byte</a> <a href="../h_src/57645888.htm" class="variable">gcstopem</a>;  <a  class="comments">/* stops emergency collections */</a>
<a id=269></a>  <a href="../h_src/57550480.htm" class="type">lu_byte</a> <a href="../h_src/57645820.htm" class="variable">genminormul</a>;  <a  class="comments">/* control for minor generational collections */</a>
<a id=270></a>  <a href="../h_src/57550480.htm" class="type">lu_byte</a> <a href="../h_src/57645752.htm" class="variable">genmajormul</a>;  <a  class="comments">/* control for major generational collections */</a>
<a id=271></a>  <a href="../h_src/57550480.htm" class="type">lu_byte</a> <a href="../h_src/57645684.htm" class="variable">gcstp</a>;  <a  class="comments">/* control whether GC is running */</a>
<a id=272></a>  <a href="../h_src/57550480.htm" class="type">lu_byte</a> <a href="../h_src/57645616.htm" class="variable">gcemergency</a>;  <a  class="comments">/* true if this is an emergency collection */</a>
<a id=273></a>  <a href="../h_src/57550480.htm" class="type">lu_byte</a> <a href="../h_src/57645548.htm" class="variable">gcpause</a>;  <a  class="comments">/* size of pause between successive GCs */</a>
<a id=274></a>  <a href="../h_src/57550480.htm" class="type">lu_byte</a> <a href="../h_src/57645480.htm" class="variable">gcstepmul</a>;  <a  class="comments">/* GC &quot;speed&quot; */</a>
<a id=275></a>  <a href="../h_src/57550480.htm" class="type">lu_byte</a> <a href="../h_src/57645412.htm" class="variable">gcstepsize</a>;  <a  class="comments">/* (log2 of) GC granularity */</a>
<a id=276></a>  <a href="../h_src/57527972.htm" class="type">GCObject</a> *<a href="../h_src/57645344.htm" class="variable">allgc</a>;  <a  class="comments">/* list of all collectable objects */</a>
<a id=277></a>  <a href="../h_src/57527972.htm" class="type">GCObject</a> **<a href="../h_src/57645208.htm" class="variable">sweepgc</a>;  <a  class="comments">/* current position of sweep in list */</a>
<a id=278></a>  <a href="../h_src/57527972.htm" class="type">GCObject</a> *<a href="../h_src/57645140.htm" class="variable">finobj</a>;  <a  class="comments">/* list of collectable objects with finalizers */</a>
<a id=279></a>  <a href="../h_src/57527972.htm" class="type">GCObject</a> *<a href="../h_src/57645072.htm" class="variable">gray</a>;  <a  class="comments">/* list of gray objects */</a>
<a id=280></a>  <a href="../h_src/57527972.htm" class="type">GCObject</a> *<a href="../h_src/57645004.htm" class="variable">grayagain</a>;  <a  class="comments">/* list of objects to be traversed atomically */</a>
<a id=281></a>  <a href="../h_src/57527972.htm" class="type">GCObject</a> *<a href="../h_src/57644936.htm" class="variable">weak</a>;  <a  class="comments">/* list of tables with weak values */</a>
<a id=282></a>  <a href="../h_src/57527972.htm" class="type">GCObject</a> *<a href="../h_src/57644868.htm" class="variable">ephemeron</a>;  <a  class="comments">/* list of ephemeron tables (weak keys) */</a>
<a id=283></a>  <a href="../h_src/57527972.htm" class="type">GCObject</a> *<a href="../h_src/57644800.htm" class="variable">allweak</a>;  <a  class="comments">/* list of all-weak tables */</a>
<a id=284></a>  <a href="../h_src/57527972.htm" class="type">GCObject</a> *<a href="../h_src/57644732.htm" class="variable">tobefnz</a>;  <a  class="comments">/* list of userdata to be GC */</a>
<a id=285></a>  <a href="../h_src/57527972.htm" class="type">GCObject</a> *<a href="../h_src/57644664.htm" class="variable">fixedgc</a>;  <a  class="comments">/* list of objects not to be collected */</a>
<a id=286></a>  <a  class="comments">/* fields for generational collector */</a>
<a id=287></a>  <a href="../h_src/57527972.htm" class="type">GCObject</a> *<a href="../h_src/57644596.htm" class="variable">survival</a>;  <a  class="comments">/* start of objects that survived one GC cycle */</a>
<a id=288></a>  <a href="../h_src/57527972.htm" class="type">GCObject</a> *<a href="../h_src/57644528.htm" class="variable">old1</a>;  <a  class="comments">/* start of old1 objects */</a>
<a id=289></a>  <a href="../h_src/57527972.htm" class="type">GCObject</a> *<a href="../h_src/57644460.htm" class="variable">reallyold</a>;  <a  class="comments">/* objects more than one cycle old (&quot;really old&quot;) */</a>
<a id=290></a>  <a href="../h_src/57527972.htm" class="type">GCObject</a> *<a href="../h_src/57644392.htm" class="variable">firstold1</a>;  <a  class="comments">/* first OLD1 object in the list (if any) */</a>
<a id=291></a>  <a href="../h_src/57527972.htm" class="type">GCObject</a> *<a href="../h_src/57644324.htm" class="variable">finobjsur</a>;  <a  class="comments">/* list of survival objects with finalizers */</a>
<a id=292></a>  <a href="../h_src/57527972.htm" class="type">GCObject</a> *<a href="../h_src/57644256.htm" class="variable">finobjold1</a>;  <a  class="comments">/* list of old1 objects with finalizers */</a>
<a id=293></a>  <a href="../h_src/57527972.htm" class="type">GCObject</a> *<a href="../h_src/57644188.htm" class="variable">finobjrold</a>;  <a  class="comments">/* list of really old objects with finalizers */</a>
<a id=294></a>  struct <a href="../h_src/57444388.htm" class="class">lua_State</a> *<a href="../h_src/57643984.htm" class="variable">twups</a>;  <a  class="comments">/* list of threads with open upvalues */</a>
<a id=295></a>  <a href="../h_src/57441736.htm" class="type">lua_CFunction</a> <a href="../h_src/57643916.htm" class="variable">panic</a>;  <a  class="comments">/* to be called in unprotected errors */</a>
<a id=296></a>  struct <a href="../h_src/57444388.htm" class="class">lua_State</a> *<a href="../h_src/57643848.htm" class="variable">mainthread</a>;
<a id=297></a>  <a href="../h_src/57522736.htm" class="type">TString</a> *<a href="../h_src/57643780.htm" class="variable">memerrmsg</a>;  <a  class="comments">/* message for memory-allocation errors */</a>
<a id=298></a>  <a href="../h_src/57522736.htm" class="type">TString</a> *<a href="../h_src/57643644.htm" class="variable">tmname</a>[<a href="../h_src/57499208.htm" class="variable">TM_N</a>];  <a  class="comments">/* array with tag-method names */</a>
<a id=299></a>  struct <a href="../h_src/57519812.htm" class="class">Table</a> *<a href="../h_src/57643440.htm" class="variable">mt</a>[<a href="../h_src/57442824.htm" class="macro">LUA_NUMTYPES</a>];  <a  class="comments">/* metatables for basic types */</a>
<a id=300></a>  <a href="../h_src/57522736.htm" class="type">TString</a> *<a href="../h_src/57643304.htm" class="variable">strcache</a>[<a href="../h_src/57544360.htm" class="macro">STRCACHE_N</a>][<a href="../h_src/57544224.htm" class="macro">STRCACHE_M</a>];  <a  class="comments">/* cache for strings in API */</a>
<a id=301></a>  <a href="../h_src/57440648.htm" class="type">lua_WarnFunction</a> <a href="../h_src/57643236.htm" class="variable">warnf</a>;  <a  class="comments">/* warning function */</a>
<a id=302></a>  void *<a href="../h_src/57643168.htm" class="variable">ud_warn</a>;         <a  class="comments">/* auxiliary data to 'warnf' */</a>
<a id=303></a>} <a href="../h_src/57643100.htm" class="type">global_State</a>;


<a id=306></a><a  class="comments">/*</a>
<a id=307></a><a  class="comments">** 'per thread' state</a>
<a id=308></a><a  class="comments">*/</a>
<a id=309></a>struct <a href="../h_src/57444388.htm" class="class">lua_State</a> {
<a id=310></a>  <a href="../h_src/57528312.htm" class="macro">CommonHeader</a>;
<a id=311></a>  <a href="../h_src/57550480.htm" class="type">lu_byte</a> <a href="../h_src/57642828.htm" class="variable">status</a>;
<a id=312></a>  <a href="../h_src/57550480.htm" class="type">lu_byte</a> <a href="../h_src/57642760.htm" class="variable">allowhook</a>;
<a id=313></a>  unsigned short <a href="../h_src/57642692.htm" class="variable">nci</a>;  <a  class="comments">/* number of items in 'ci' list */</a>
<a id=314></a>  <a href="../h_src/57531780.htm" class="type">StkIdRel</a> <a href="../h_src/57642624.htm" class="variable">top</a>;  <a  class="comments">/* first free slot in the stack */</a>
<a id=315></a>  <a href="../h_src/57643100.htm" class="type">global_State</a> *<a href="../h_src/57642488.htm" class="variable">l_G</a>;
<a id=316></a>  <a href="../h_src/57537764.htm" class="type">CallInfo</a> *<a href="../h_src/57642420.htm" class="variable">ci</a>;  <a  class="comments">/* call info for current function */</a>
<a id=317></a>  <a href="../h_src/57531780.htm" class="type">StkIdRel</a> <a href="../h_src/57642352.htm" class="variable">stack_last</a>;  <a  class="comments">/* end of stack (last element + 1) */</a>
<a id=318></a>  <a href="../h_src/57531780.htm" class="type">StkIdRel</a> <a href="../h_src/57642284.htm" class="variable">stack</a>;  <a  class="comments">/* stack base */</a>
<a id=319></a>  <a href="../h_src/57509612.htm" class="type">UpVal</a> *<a href="../h_src/57642216.htm" class="variable">openupval</a>;  <a  class="comments">/* list of open upvalues in this stack */</a>
<a id=320></a>  <a href="../h_src/57531780.htm" class="type">StkIdRel</a> <a href="../h_src/57642148.htm" class="variable">tbclist</a>;  <a  class="comments">/* list of to-be-closed variables */</a>
<a id=321></a>  <a href="../h_src/57527972.htm" class="type">GCObject</a> *<a href="../h_src/57642080.htm" class="variable">gclist</a>;
<a id=322></a>  struct <a href="../h_src/57444388.htm" class="class">lua_State</a> *<a href="../h_src/57642012.htm" class="variable">twups</a>;  <a  class="comments">/* list of threads with open upvalues */</a>
<a id=323></a>  struct <a href="../h_src/57653096.htm" class="class">lua_longjmp</a> *<a href="../h_src/57641808.htm" class="variable">errorJmp</a>;  <a  class="comments">/* current error recover point */</a>
<a id=324></a>  <a href="../h_src/57537764.htm" class="type">CallInfo</a> <a href="../h_src/57641740.htm" class="variable">base_ci</a>;  <a  class="comments">/* CallInfo for first level (C calling Lua) */</a>
<a id=325></a>  volatile <a href="../h_src/57440240.htm" class="type">lua_Hook</a> <a href="../h_src/57641672.htm" class="variable">hook</a>;
<a id=326></a>  <a href="../h_aa/57441872.htm" class="type">ptrdiff_t</a> <a href="../h_src/57641604.htm" class="variable">errfunc</a>;  <a  class="comments">/* current error handling function (stack index) */</a>
<a id=327></a>  <a href="../h_src/57545176.htm" class="type">l_uint32</a> <a href="../h_src/57641536.htm" class="variable">nCcalls</a>;  <a  class="comments">/* number of nested (non-yieldable | C)  calls */</a>
<a id=328></a>  int <a href="../h_src/57641468.htm" class="variable">oldpc</a>;  <a  class="comments">/* last pc traced */</a>
<a id=329></a>  int <a href="../h_src/57641400.htm" class="variable">basehookcount</a>;
<a id=330></a>  int <a href="../h_src/57641332.htm" class="variable">hookcount</a>;
<a id=331></a>  volatile <a href="../h_src/57652824.htm" class="macro">l_signalT</a> <a href="../h_src/57641264.htm" class="variable">hookmask</a>;
};


<a id=335></a>#define <a href="../h_src/57641196.htm" class="macro">G</a>(L)	(L-&gt;l_G)

<a id=337></a><a  class="comments">/*</a>
<a id=338></a><a  class="comments">** 'g-&gt;nilvalue' being a nil value flags that the state was completely</a>
<a id=339></a><a  class="comments">** build.</a>
<a id=340></a><a  class="comments">*/</a>
<a id=341></a>#define <a href="../h_src/57641060.htm" class="macro">completestate</a>(g)	ttisnil(&amp;g-&gt;nilvalue)


<a id=344></a><a  class="comments">/*</a>
<a id=345></a><a  class="comments">** Union of all collectable objects (only for conversions)</a>
<a id=346></a><a  class="comments">** ISO C99, 6.5.2.3 p.5:</a>
<a id=347></a><a  class="comments">** &quot;if a union contains several structures that share a common initial</a>
<a id=348></a><a  class="comments">** sequence [...], and if the union object currently contains one</a>
<a id=349></a><a  class="comments">** of these structures, it is permitted to inspect the common initial</a>
<a id=350></a><a  class="comments">** part of any of them anywhere that a declaration of the complete type</a>
<a id=351></a><a  class="comments">** of the union is visible.&quot;</a>
<a id=352></a><a  class="comments">*/</a>
<a id=353></a>union <a href="../h_src/57640924.htm" class="class">GCUnion</a> {
<a id=354></a>  <a href="../h_src/57527972.htm" class="type">GCObject</a> <a href="../h_src/57640788.htm" class="variable">gc</a>;  <a  class="comments">/* common header */</a>
<a id=355></a>  struct <a href="../h_src/57523824.htm" class="class">TString</a> <a href="../h_src/57640720.htm" class="variable">ts</a>;
<a id=356></a>  struct <a href="../h_src/57520288.htm" class="class">Udata</a> <a href="../h_src/57640652.htm" class="variable">u</a>;
<a id=357></a>  union <a href="../h_src/57507912.htm" class="class">Closure</a> <a href="../h_src/57640584.htm" class="variable">cl</a>;
<a id=358></a>  struct <a href="../h_src/57519812.htm" class="class">Table</a> <a href="../h_src/57640516.htm" class="variable">h</a>;
<a id=359></a>  struct <a href="../h_src/57516276.htm" class="class">Proto</a> <a href="../h_src/57640448.htm" class="variable">p</a>;
<a id=360></a>  struct <a href="../h_src/57444388.htm" class="class">lua_State</a> <a href="../h_src/57640380.htm" class="variable">th</a>;  <a  class="comments">/* thread */</a>
<a id=361></a>  struct <a href="../h_src/57511176.htm" class="class">UpVal</a> <a href="../h_src/57640312.htm" class="variable">upv</a>;
};


<a id=365></a><a  class="comments">/*</a>
<a id=366></a><a  class="comments">** ISO C99, 6.7.2.1 p.14:</a>
<a id=367></a><a  class="comments">** &quot;A pointer to a union object, suitably converted, points to each of</a>
<a id=368></a><a  class="comments">** its members [...], and vice versa.&quot;</a>
<a id=369></a><a  class="comments">*/</a>
<a id=370></a>#define <a href="../h_src/57640244.htm" class="macro">cast_u</a>(o)	cast(union GCUnion *, (o))

<a id=372></a><a  class="comments">/* macros to convert a GCObject into a specific value */</a>
<a id=373></a>#define <a href="../h_src/57640108.htm" class="macro">gco2ts</a>(o)  \
	check_exp(novariant((o)-&gt;tt) == LUA_TSTRING, &amp;((cast_u(o))-&gt;ts))
<a id=375></a>#define <a href="../h_src/57639972.htm" class="macro">gco2u</a>(o)  check_exp((o)-&gt;tt == LUA_VUSERDATA, &amp;((cast_u(o))-&gt;u))
<a id=376></a>#define <a href="../h_src/57639836.htm" class="macro">gco2lcl</a>(o)  check_exp((o)-&gt;tt == LUA_VLCL, &amp;((cast_u(o))-&gt;cl.l))
<a id=377></a>#define <a href="../h_src/57639700.htm" class="macro">gco2ccl</a>(o)  check_exp((o)-&gt;tt == LUA_VCCL, &amp;((cast_u(o))-&gt;cl.c))
<a id=378></a>#define <a href="../h_src/57639564.htm" class="macro">gco2cl</a>(o)  \
	check_exp(novariant((o)-&gt;tt) == LUA_TFUNCTION, &amp;((cast_u(o))-&gt;cl))
<a id=380></a>#define <a href="../h_src/57639428.htm" class="macro">gco2t</a>(o)  check_exp((o)-&gt;tt == LUA_VTABLE, &amp;((cast_u(o))-&gt;h))
<a id=381></a>#define <a href="../h_src/57639292.htm" class="macro">gco2p</a>(o)  check_exp((o)-&gt;tt == LUA_VPROTO, &amp;((cast_u(o))-&gt;p))
<a id=382></a>#define <a href="../h_src/57639156.htm" class="macro">gco2th</a>(o)  check_exp((o)-&gt;tt == LUA_VTHREAD, &amp;((cast_u(o))-&gt;th))
<a id=383></a>#define <a href="../h_src/57639020.htm" class="macro">gco2upv</a>(o)	check_exp((o)-&gt;tt == LUA_VUPVAL, &amp;((cast_u(o))-&gt;upv))


<a id=386></a><a  class="comments">/*</a>
<a id=387></a><a  class="comments">** macro to convert a Lua object into a GCObject</a>
<a id=388></a><a  class="comments">** (The access to 'tt' tries to ensure that 'v' is actually a Lua object.)</a>
<a id=389></a><a  class="comments">*/</a>
<a id=390></a>#define <a href="../h_src/57638884.htm" class="macro">obj2gco</a>(v)	check_exp((v)-&gt;tt &gt;= LUA_TSTRING, &amp;(cast_u(v)-&gt;gc))


<a id=393></a><a  class="comments">/* actual number of total bytes allocated */</a>
<a id=394></a>#define <a href="../h_src/57638748.htm" class="macro">gettotalbytes</a>(g)	cast(lu_mem, (g)-&gt;totalbytes + (g)-&gt;GCdebt)

<a id=396></a><a href="../h_src/57453908.htm" class="macro">LUAI_FUNC</a> void <a href="../h_src/57638612.htm" class="function">luaE_setdebt</a> (<a href="../h_src/57643100.htm" class="type">global_State</a> *g, <a href="../h_src/57550548.htm" class="type">l_mem</a> debt);
<a id=397></a><a href="../h_src/57453908.htm" class="macro">LUAI_FUNC</a> void <a href="../h_src/57638544.htm" class="function">luaE_freethread</a> (<a href="../h_src/57444252.htm" class="type">lua_State</a> *L, <a href="../h_src/57444252.htm" class="type">lua_State</a> *L1);
<a id=398></a><a href="../h_src/57453908.htm" class="macro">LUAI_FUNC</a> <a href="../h_src/57537764.htm" class="type">CallInfo</a> *<a href="../h_src/57638476.htm" class="function">luaE_extendCI</a> (<a href="../h_src/57444252.htm" class="type">lua_State</a> *L);
<a id=399></a><a href="../h_src/57453908.htm" class="macro">LUAI_FUNC</a> void <a href="../h_src/57638408.htm" class="function">luaE_freeCI</a> (<a href="../h_src/57444252.htm" class="type">lua_State</a> *L);
<a id=400></a><a href="../h_src/57453908.htm" class="macro">LUAI_FUNC</a> void <a href="../h_src/57638340.htm" class="function">luaE_shrinkCI</a> (<a href="../h_src/57444252.htm" class="type">lua_State</a> *L);
<a id=401></a><a href="../h_src/57453908.htm" class="macro">LUAI_FUNC</a> void <a href="../h_src/57638272.htm" class="function">luaE_checkcstack</a> (<a href="../h_src/57444252.htm" class="type">lua_State</a> *L);
<a id=402></a><a href="../h_src/57453908.htm" class="macro">LUAI_FUNC</a> void <a href="../h_src/57638204.htm" class="function">luaE_incCstack</a> (<a href="../h_src/57444252.htm" class="type">lua_State</a> *L);
<a id=403></a><a href="../h_src/57453908.htm" class="macro">LUAI_FUNC</a> void <a href="../h_src/57638136.htm" class="function">luaE_warning</a> (<a href="../h_src/57444252.htm" class="type">lua_State</a> *L, const char *msg, int tocont);
<a id=404></a><a href="../h_src/57453908.htm" class="macro">LUAI_FUNC</a> void <a href="../h_src/57638068.htm" class="function">luaE_warnerror</a> (<a href="../h_src/57444252.htm" class="type">lua_State</a> *L, const char *where);
<a id=405></a><a href="../h_src/57453908.htm" class="macro">LUAI_FUNC</a> int <a href="../h_src/57638000.htm" class="function">luaE_resetthread</a> (<a href="../h_src/57444252.htm" class="type">lua_State</a> *L, int status);


#endif

</pre>
<div class="footer">
Generated on 13 Dec 2023 (09:27) by <a class="footer" href="http://www.imagix.com">Imagix 4D</a>
</div>
</body>
</html>

